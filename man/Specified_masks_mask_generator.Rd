% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/approach_vaeac.R
\name{Specified_masks_mask_generator}
\alias{Specified_masks_mask_generator}
\title{Specified_probability_mask_generator}
\usage{
Specified_masks_mask_generator(masks, masks_probs, paired_sampling = FALSE)
}
\arguments{
\item{masks}{Matrix/Tensor of possible/allowed 'masks' which we sample from.}

\item{masks_probs}{Array of 'probabilities' for each of the masks specified in 'masks'.
Note that they do not need to be between 0 and 1. They are scaled, hence, they only need to be positive.}

\item{paired_sampling}{Boolean. If we are doing paired sampling. So include both S and \bar{S}.
If TRUE, then batch must be sampled using 'paired_sampler' which creates batches where
the first half and second half of the rows are duplicates of each other. That is,
batch = \link{row1, row1, row2, row2, row3, row3, ...}.}

\item{batch}{Matrix/Tensor. Only used to get the dimensions and to check if any of the
entries are missing. If any are missing, then the returned mask will ensure that
these missing entries are masked.}

\item{seed}{Integer. Used to set the seed for the sampling process such that we
can reproduce the same masks.}
}
\value{
A binary matrix of the same size as 'batch'. An entry of '1' indicates that the
observed feature value will be masked. '0' means that the entry is NOT masked,
i.e., the feature value will be observed/given/available.
}
\description{
Used for Shapley value estimation when only a subset of coalitions are used to compute the Shapley values.

Initialize a specified masks mask generator.

Generates a mask by calling self$Specified_masks_mask_generator_function function.

Functions that samples masks from the provided masks.
}
\details{
Function that takes in a 'batch' of observations and matrix of possible/allowed
'masks' which we are going to sample from based on the provided probability in 'masks_probs'.
Function returns a mask of same shape as batch. Note that the batch can contain missing values,
indicated by the "NaN" token. The mask will always mask missing values.
}
\examples{
masks = torch::torch_tensor(matrix(c(0,0,1,0, 1,0,1,0, 1,1,1,1), nrow = 3, ncol = 4, byrow = TRUE))
masks_probs = c(3, 1, 6)
mask_gen = Specified_masks_mask_generator(masks = masks, masks_probs = masks_probs)
empirical_prob = table(as.array(mask_gen(torch::torch_randn(c(10000, ncol(masks))))$sum(-1)))
empirical_prob / sum(empirical_prob)
masks_probs / sum(masks_probs)
}
