% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/approach_vaeac.R
\name{VAEAC}
\alias{VAEAC}
\title{Initializing a VAEAC Model}
\usage{
VAEAC(
  one_hot_max_sizes,
  width = 32,
  depth = 3,
  latent_dim = 8,
  activation_function = torch::nn_relu,
  use_skip_connections = FALSE,
  use_skip_connections_between_masked_encoder_and_decoder = FALSE,
  use_batch_normalization = FALSE,
  paired_sampling = FALSE,
  mask_generator_name = c("MCAR_mask_generator", "Specified_probability_mask_generator",
    "Specified_masks_mask_generator"),
  masking_ratio = 0.5,
  mask_generator_only_these_coalitions = NULL,
  mask_generator_only_these_coalitions_probabilities = NULL,
  sigma_mu = 10000,
  sigma_sigma = 1e-04
)
}
\arguments{
\item{one_hot_max_sizes}{A torch tensor of dimension p containing the one hot sizes of the p features.
The sizes for the continuous features can either be '0' or '1'.}

\item{width}{Integer. The number of neurons in each hidden layer in the neural networks of the masked encoder, full encoder, and decoder.}

\item{depth}{Integer. The number of hidden layers in the neural networks of the masked encoder, full encoder, and decoder.}

\item{latent_dim}{Integer. The number of dimensions in the latent space.}

\item{activation_function}{An torch::nn_module representing an activation function. E.g., torch::nn_relu, torch::nn_leaky_relu, torch::nn_selu, torch::nn_sigmoid.}

\item{use_skip_connections}{Boolean. If we are to use skip connections in each layer. If true, then we add the input to the outcome of each hidden layer, so the output becomes X + activation(WX + b). I.e., identity skip connection.}

\item{use_skip_connections_between_masked_encoder_and_decoder}{Boolean. If we are to apply concatenate skip connections between the layers in the masked encoder and decoder.}

\item{use_batch_normalization}{Boolean. If we are to use batch normalization after the activation function. Note that if \code{use_skip_connections} is TRUE, then the normalization is
done after the adding from the skip connection. I.e, we batch normalize the whole quantity X + activation(WX + b).}

\item{paired_sampling}{TODO}

\item{mask_generator_name}{String specifying the type of mask generator to use. Need to be one of "MCAR_mask_generator", "Specified_probability_mask_generator", and "Specified_masks_mask_generator".}

\item{masking_ratio}{Scalar. The probability for an entry in the generated mask to be 1 (masked). Not used if \code{mask_generator_only_these_coalitions} is given.}

\item{mask_generator_only_these_coalitions}{Matrix containing the different coalitions to learn. Must be given if \code{mask_generator_name} = "Specified_masks_mask_generator".}

\item{mask_generator_only_these_coalitions_probabilities}{Numerics containing the probabilities for sampling each mask in \code{mask_generator_only_these_coalitions}.
Array containing the probabilities for sampling the coalitions in \code{mask_generator_only_these_coalitions}.}

\item{sigma_mu}{Numeric representing a hyperparameter in the normal-gamma prior used on the masked encoder, see Section 3.3.1 in Olsen et al. (2022).}

\item{sigma_sigma}{Numeric representing a hyperparameter in the normal-gamma prior used on the masked encoder, see Section 3.3.1 in Olsen et al. (2022).}

\item{...}{Anything, as the function does not use it.
Apply Mask to Batch to Create Observed Batch}

\item{only_masked_encoder}{Boolean. If we are only to compute the latent distributions for the masked encoder.
Used in deployment phase when we do not have access to the full data. Always FALSE in the training phase.
Compute the Regularizes for the Latent Distribution Inferred by the Masked Encoder.}

\item{masked_encoder}{The torch_Normal object returned when calling the masked encoder.
Compute the Variational Lower Bound for the Observations in the Batch}

\item{batch}{Tensor of dimension batch_size x num_features containing a batch of observations.}

\item{mask}{Tensor of zeros and ones indicating which entries in batch to mask. Same dimension as \code{batch}.}

\item{K}{Integer. The number of imputations to be done for each observation in batch.}
}
\value{
Returns a list with the neural networks of the masked encoder, full encoder, and decoder together
with reconstruction log probability function, optimizer constructor, sampler from the decoder output,
mask generator, batch size, and scale factor for the stability of the variational lower bound optimization.
}
\description{
Class that represents a VAEAC model. Create the Neural Networks and Training Utilities used in VAEAC.

Forward functions are required in torch::nn_modules, but is it not needed in the way we have implemented VAEAC.

Clones the batch and applies the mask to set masked entries to 0 to create the observed batch.

Compute the parameters for the latent normal distributions inferred by the encoders.
If \code{only_masked_encoder = TRUE}, then we only compute the latent normal distributions inferred by the
masked encoder. This is used in the deployment phase when we do not have access to the full observation.

The masked encoder (prior) distribution regularization in the latent space.
This is used to compute the extended variational lower bound used to train VAEAC, see
Section 3.3.1 in Olsen et al. (2022).
Though regularizing prevents the masked encoder distribution parameters from going to infinity,
the model usually doesn't diverge even without this regularization. It almost doesn't affect
learning process near zero with default regularization parameters which are recommended to be used.

Compute differentiable lower bound for the given batch of objects and mask.
Used as the (negative) loss function for training the VAEAC model.

Compute IWAE log likelihood estimate with K samples per object.

Generate the parameters of the generative distributions for samples from the batch.
}
\details{
This function builds neural networks (masked encoder, full encoder, decoder) given
the list of one-hot max sizes of the features in the dataset we use to train the VAEAC model,
and the provided parameters for the networks. It also create reconstruction log probability function,
and method for sampling from the decoder output. And then use this to create the VAEAC model.

Technically, it is differentiable, but it is recommended to use it for
evaluation purposes inside torch.no_grad in order to save memory. With torch::with_no_grad
the method almost doesn't require extra memory for very large K. The method makes K independent
passes through decoder network, so the batch size is the same as for training with batch_vlb.
IWAE is an abbreviation for Importance Sampling Estimator
log p_{theta, psi}(x|y) approx
log {1/K * sum_{i=1}^K \link{p_theta(x|z_i, y) * p_psi(z_i|y) / q_phi(z_i|x,y)}} =
log {sum_{i=1}^K exp(log\link{p_theta(x|z_i, y) * p_psi(z_i|y) / q_phi(z_i|x,y)})} - log(K) =
log {sum_{i=1}^K exp(log\link{p_theta(x|z_i, y)} + log\link{p_psi(z_i|y)} - log\link{q_phi(z_i|x,y)})} - log(K) =
logsumexp(log\link{p_theta(x|z_i, y)} + log\link{p_psi(z_i|y)} - log\link{q_phi(z_i|x,y)}) - log(K) =
logsumexp(rec_loss + prior_log_prob - proposal_log_prob) - log(K),
where z_i ~ q_phi(z|x,y).

The function makes K latent representation for each object from the batch, send these
latent representations through the decoder to obtain the parameters for the generative distributions.
I.e., means and variances for the normal distributions (continuous features) and probabilities
for the categorical distribution (categorical features).
The second axis is used to index samples for an object, i.e. if the batch shape is \link{n x D1 x D2}, then
the result shape is \link{n x K x D1 x D2}. It is better to use it inside torch::with_no_grad in order to save
memory. With torch::with_no_grad the method doesn't require extra memory except the memory for the result.
}
