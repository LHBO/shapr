% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/asymmetric_and_casual_Shapley.R
\name{get_S_causal_steps}
\alias{get_S_causal_steps}
\title{Get the steps for generating MC samples for coalitions following a causal ordering}
\usage{
get_S_causal_steps(S, causal_ordering, confounding, as_string = FALSE)
}
\arguments{
\item{S}{ADD inheritParams from somewhere else. NOTE that we assume that this S has been checked. I.e., it only
contains coalitions that respects the causal order.}

\item{causal_ordering}{List of vectors containing the partial causal ordering.
The elements in the list represents the components in the causal ordering and can either
be a single feature index or several, that is, a vector. For example, we can have
\code{list(c(1,2), c(3, 4))}, which means that \verb{1,2 -> 3} and \verb{1,2 -> 4}, i.e., one and
two are the ancestors of three and four, but three and four are not related.}

\item{confounding}{Boolean or boolean vector specifying which features are affected by confounding. If a single
boolean is given, then each component is given this value. Otherwise, \code{confounding} must be a vector of length
\code{causal_ordering} specifying if each component in the causal order is subject to confounding or not.}

\item{as_string}{Boolean.
If the returned object is to be a list of lists of integers or a list of vectors of strings.}
}
\value{
Depends on the value of the parameter \code{as_string}. If a string, then \code{results[j]} is a vector specifying
the process of generating the samples for coalition \code{j}. The length of \code{results[j]} is the number of steps, and
\code{results[j][i]} is a string of the form \code{features_to_sample|features_to_condition_on}. If the
\code{features_to_condition_on} part is blank, then we are to sample from the marginal distribution.
For \code{as_string == FALSE}, then we rather return a vector where \code{results[[j]][[i]]} contains the elements
\code{Sbar} and \code{S} representing the features to sample and condition on, respectively.
}
\description{
Get the steps for generating MC samples for coalitions following a causal ordering
}
\examples{
m <- 5
causal_ordering <- list(1:2, 3:4, 5)
S <- shapr::feature_matrix_cpp(get_valid_causal_coalitions(causal_ordering = causal_ordering),
  m = m
)
confounding <- c(TRUE, TRUE, FALSE)
get_S_causal_steps(S, causal_ordering, confounding, as_string = TRUE)

# Look at the effect of changing the confounding assumptions
SS1 <- get_S_causal_steps(S, causal_ordering,
  confounding = c(FALSE, FALSE, FALSE),
  as_string = TRUE
)
SS2 <- get_S_causal_steps(S, causal_ordering, confounding = c(TRUE, FALSE, FALSE), as_string = TRUE)
SS3 <- get_S_causal_steps(S, causal_ordering, confounding = c(TRUE, TRUE, FALSE), as_string = TRUE)
SS4 <- get_S_causal_steps(S, causal_ordering, confounding = c(TRUE, TRUE, TRUE), as_string = TRUE)

all.equal(SS1, SS2)
SS1[[2]] # Condition on 1 as there is no confounding in the first component
SS2[[2]] # Do NOT condition on 1 as there is confounding in the first component
SS1[[3]]
SS2[[3]]

all.equal(SS1, SS3)
SS1[[2]] # Condition on 1 as there is no confounding in the first component
SS3[[2]] # Do NOT condition on 1 as there is confounding in the first component
SS1[[5]] # Condition on 3 as there is no confounding in the second component
SS3[[5]] # Do NOT condition on 3 as there is confounding in the second component
SS1[[6]]
SS3[[6]]

all.equal(SS2, SS3)
SS2[[5]]
SS3[[5]]
SS2[[6]]
SS3[[6]]

all.equal(SS3, SS4) # No difference as the last component is a singleton

}
\author{
Lars Henry Berge Olsen
}
\keyword{internal}
